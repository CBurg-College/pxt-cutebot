{"entries":[{"timestamp":1753734312343,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":6402,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":117,"length1":134,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":234,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1753735094500,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":902,"length1":0,"diffs":[[1,"namespace TrackSensor {\r\n\r\n    let RJPORT = 0\r\n\r\n    export function setPort(port: RJPort) {\r\n        RJPORT = port\r\n    }\r\n\r\n    export function read(): Tracking {\r\n        let rpin = Nezha.digitalPinA(RJPORT)\r\n        let lpin = Nezha.digitalPinB(RJPORT)\r\n        pins.setPull(rpin, PinPullMode.PullUp)\r\n        pins.setPull(lpin, PinPullMode.PullUp)\r\n        let rsensor = pins.digitalReadPin(rpin)\r\n        let lsensor = pins.digitalReadPin(lpin)\r\n        if (lsensor == 0 && rsensor == 0)\r\n            return Tracking.Both\r\n        if (lsensor == 0 && rsensor == 1)\r\n            return Tracking.Left\r\n        if (lsensor == 1 && rsensor == 0)\r\n            return Tracking.Right\r\n        return Tracking.None\r\n    }\r\n}\r\n\r\nenum TrackValue {\r\n    //% block=\"◌\" \r\n    Off = 0,\r\n    //% block=\"●\" \r\n    On = 1\r\n}\r\n\r\n"]]}]}]},{"timestamp":1753735096898,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1222,"length1":52,"diffs":[[1,"namespace CutebotProV2 {\r\n"]]},{"start1":2243,"length1":69,"diffs":[[1,"    export function motorControl(leftSpeed: number, rightSpeed: number): void {\r\n"]]},{"start1":2397,"length1":165,"diffs":[[1,"        if (leftSpeed < 0)\r\n            direction |= 0x01;\r\n        if (rightSpeed < 0)\r\n            direction |= 0x02;\r\n        i2cCommandSend(0x10, [2, Math.abs(leftSpeed), Math.abs(rightSpeed), direction]);\r\n"]]},{"start1":4111,"length1":211,"diffs":[[1,"    /*\r\n        export function trackSensor(sensor: TrackSensor): number {\r\n            let channel: number\r\n            switch (sensor) {\r\n                case TrackSensor.FarLeft: channel = 0; break;\r\n                case TrackSensor.Left: channel = 0; break;\r\n                case TrackSensor.Right: channel = 0; break;\r\n                case TrackSensor.FarRight: channel = 0; break;\r\n            }\r\n            i2cCommandSend(0x60, [0x02, channel])\r\n            return pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, false)\r\n        }\r\n    */\r\n"]]}]}]},{"timestamp":1753735574050,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":131,"diffs":[[1,"enum Led {\r\n    //% block=\"left led\"\r\n    //% block.loc.nl=\"linker led\"\r\n    Left,\r\n    //% block=\"right led\"\r\n    //% block.loc.nl=\"rechter led\"\r\n    Right,\r\n    //% block=\"both leds\"\r\n    //% block.loc.nl=\"beide leds\"\r\n    Both\r\n"]]},{"start1":236,"length1":138,"diffs":[[1,""]]},{"start1":902,"length1":236,"diffs":[[1,""]]},{"start1":2269,"length1":90,"diffs":[[1,"    export function motorSpeed(left: number, right: number): void {\r\n"]]},{"start1":3460,"length1":21,"diffs":[[1,"    export function servoControl(angle: number): void {\r\n        // angle [0, 180]\r\n"]]},{"start1":3546,"length1":157,"diffs":[[1,"        i2cCommandSend(0x40, [1, angle]);\r\n"]]},{"start1":3598,"length1":205,"diffs":[[1,""]]},{"start1":3880,"length1":26,"diffs":[[1,""]]}]}]},{"timestamp":1753736131820,"editorVersion":"8.0.11","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":237,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":4869,"length1":26,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":342,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests gaan hier; deze zal niet worden gecompileerd wanneer dit pakket wordt gebruikt als extensie.\n"}]}],"snapshots":[{"timestamp":1753734312342,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-cutebot\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1753736115839,"editorVersion":"8.0.11","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"enum Servo {\r\n    //% block=\"S1\" \r\n    S1,\r\n    //% block=\"S2\"\r\n    S2,\r\n    //% block=\"S3\" \r\n    S3,\r\n    //% block=\"S4\"\r\n    S4\r\n}\r\n\r\nenum ServoType {\r\n    //% block=\"180\"\r\n    ST180 = 180,\r\n    //% block=\"180\"\r\n    ST27 = 270,\r\n    //% block=\"360\"\r\n    ST360 = 360\r\n}\r\n\r\nenum Tracking {\r\n    //% block=\"◌ ◌ ◌ ◌\" \r\n    State_0,\r\n    //% block=\"● ◌ ◌ ◌\" \r\n    State_1,\r\n    //% block=\"◌ ● ◌ ◌\" \r\n    State_2,\r\n    //% block=\"● ● ◌ ◌\" \r\n    State_3,\r\n    //% block=\"◌ ◌ ● ◌\" \r\n    State_4,\r\n    //% block=\"● ◌ ● ◌\" \r\n    State_5,\r\n    //% block=\"◌ ● ● ◌\" \r\n    State_6,\r\n    //% block=\"● ● ● ◌\" \r\n    State_7,\r\n    //% block=\"◌ ◌ ◌ ●\" \r\n    State_8,\r\n    //% block=\"● ◌ ◌ ●\" \r\n    State_9,\r\n    //% block=\"◌ ● ◌ ●\" \r\n    State_10,\r\n    //% block=\"● ● ◌ ●\"\r\n    State_11,\r\n    //% block=\"◌ ◌ ● ●\" \r\n    State_12,\r\n    //% block=\"● ◌ ● ●\" \r\n    State_13,\r\n    //% block=\"◌ ● ● ●\" \r\n    State_14,\r\n    //% block=\"● ● ● ●\" \r\n    State_15\r\n}\r\n\r\nenum Led {\r\n    //% block=\"left led\"\r\n    //% block.loc.nl=\"linker led\"\r\n    Left,\r\n    //% block=\"right led\"\r\n    //% block.loc.nl=\"rechter led\"\r\n    Right,\r\n    //% block=\"both leds\"\r\n    //% block.loc.nl=\"beide leds\"\r\n    Both\r\n}\r\n\r\nenum TrackSensor {\r\n    //% block=\"far left\"\r\n    //% block.loc.nl=\"ver links\"\r\n    FarLeft = 1,\r\n    //% block=\"left\"\r\n    //% block.loc.nl=\"links\"\r\n    Left = 2,\r\n    //% block=\"right\"\r\n    //% block.loc.nl=\"rechts\"\r\n    Right = 4,\r\n    //% block=\"far right\"\r\n    //% block.loc.nl=\"ver rechts\"\r\n    FarRight = 8\r\n}\r\n\r\nnamespace Cutebot {\r\n    // supports CutebotPro V2\r\n\r\n    const cutebotProAddr = 0x10\r\n\r\n    function delay_ms(ms: number) {\r\n        let endTime = input.runningTime() + ms;\r\n        while (endTime > input.runningTime()) { }\r\n    }\r\n\r\n    export function pid_delay_ms(ms: number) {\r\n        let time = control.millis() + ms\r\n        while (1) {\r\n            i2cCommandSend(0xA0, [0x05])\r\n            if (pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, false) || control.millis() >= time) {\r\n                basic.pause(500)\r\n                break\r\n            }\r\n            basic.pause(10)\r\n        }\r\n    }\r\n\r\n    export function i2cCommandSend(command: number, params: number[]) {\r\n        let buff = pins.createBuffer(params.length + 4);\r\n        buff[0] = 0xFF;\r\n        buff[1] = 0xF9;\r\n        buff[2] = command;\r\n        buff[3] = params.length;\r\n        for (let i = 0; i < params.length; i++) {\r\n            buff[i + 4] = params[i];\r\n        }\r\n        pins.i2cWriteBuffer(cutebotProAddr, buff);\r\n        delay_ms(1);\r\n    }\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function setSpeed(left: number, right: number): void {\r\n        // speed in % [-100, 100]\r\n\r\n        let direction: number = 0;\r\n        if (left < 0) direction |= 0x01;\r\n        if (right < 0) direction |= 0x02;\r\n        i2cCommandSend(0x10, [2, Math.abs(left), Math.abs(right), direction]);\r\n    }\r\n\r\n    export function move(speed: number, distance: number): void {\r\n        // speed in % [-100, -40] backward and [40, 100] forward\r\n        // distance in cm [0, 6000]\r\n\r\n        distance = ((distance > 6000 ? 6000 : distance) < 0 ? 0 : distance);\r\n        distance *= 10 // cm to mm\r\n        let distance_h = distance >> 8;\r\n        let distance_l = distance & 0xFF;\r\n\r\n        let direction2: number\r\n        if (speed <= 0) {\r\n            speed = -speed\r\n            direction2 = 3\r\n        } else\r\n            direction2 = 0\r\n\r\n        speed *= 5 // % to mm/s\r\n        speed = ((speed > 500 ? 500 : speed) < 200 ? 200 : speed);\r\n        let speed_h = speed >> 8;\r\n        let speed_l = speed & 0xFF;\r\n\r\n        i2cCommandSend(0x84, [distance_h, distance_l, speed_h, speed_l, direction2]);\r\n        pid_delay_ms(Math.round(distance * 1.0 / 1000 * 8000 + 3000))\r\n    }\r\n\r\n    // SERVO MODULE\r\n\r\n    let Servos = [180, 180, 180, 180] // all ServoType.ST180\r\n\r\n    export function setServoType(servo: Servo, st: ServoType) {\r\n        Servos[servo] = st\r\n    }\r\n\r\n    export function servoAngle(servo: Servo, angle: number): void {\r\n        angle = Math.map(angle, 0, Servos[servo], 0, 180)\r\n        i2cCommandSend(0x40, [servo, angle]);\r\n    }\r\n\r\n    // MOTOR MODULE\r\n\r\n    export function ledColor(led: Led, color: Color): void {\r\n        let rgbval = rgb(color)\r\n        let red = (rgbval >> 16) & 0xFF;\r\n        let green = (rgbval >> 8) & 0xFF;\r\n        let blue = (rgbval) & 0xFF;\r\n        i2cCommandSend(0x20, [led, red, green, blue]);\r\n    }\r\n\r\n    export function readTracking(): number {\r\n        i2cCommandSend(0x60, [0x00])\r\n        let state = pins.i2cReadNumber(cutebotProAddr, NumberFormat.UInt8LE, true)\r\n        return state\r\n    }\r\n\r\n    // track can be a combination of OR-ed TrackSensor values\r\n    export function isOnTrack(track:TrackSensor) : boolean {\r\n        let state = (readTracking() & track)\r\n        return (state == track)\r\n    }\r\n\r\n    export function readDistance(): number {\r\n        // send pulse\r\n\r\n        pins.setPull(DigitalPin.P8, PinPullMode.PullNone);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n        control.waitMicros(2);\r\n        pins.digitalWritePin(DigitalPin.P8, 1);\r\n        control.waitMicros(10);\r\n        pins.digitalWritePin(DigitalPin.P8, 0);\r\n\r\n        // read pulse\r\n\r\n        // the next code is replacing the original since\r\n        // driving the motors causes interference with pulseIn\r\n\r\n        while (!pins.digitalReadPin(DigitalPin.P12)) { }\r\n        let tm1 = input.runningTimeMicros()\r\n        while (pins.digitalReadPin(DigitalPin.P12)) {\r\n            if (input.runningTimeMicros() - tm1 > 7288)\r\n                return 999 // timeout at further than 250 cm\r\n        }\r\n        let tm2 = input.runningTimeMicros()\r\n        let dist = (tm2 - tm1) * 343 / 20000\r\n        return Math.floor(dist)\r\n    }\r\n}\r\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-cutebot\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-colorsensor\": \"github:CBurg-College/pxt-colorsensor#c6f957d1eeb75d762934345480beb3be0781bd1c\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1753736515576}